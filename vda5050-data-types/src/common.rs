use serde::{Deserialize, Serialize};

/// The header is part of each VDA 5050 message.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Header {
    /// Unique continuous number, can be used to identify lost messages.
    /// Recommended to be generated by the AGV.
    /// On receiving a message, the receiver can check for gaps in the sequence.
    pub header_id: u32,
    /// Timestamp in ISO 8601 format. YYYY-MM-DDTHH:mm:ss.ssZ
    /// The timestamp should be in UTC.
    pub timestamp: String,
    /// VDA 5050 version, e.g. "2.0.0".
    pub version: String,
    /// Name of the AGV manufacturer.
    pub manufacturer: String,
    /// Serial number of the AGV.
    pub serial_number: String,
}

/// An action that is to be executed by the AGV.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Action {
    /// Unique identifier for the action.
    /// The actionId is to be used in the state message to report the progress of an action.
    pub action_id: String,
    /// Type of the action.
    /// The actionType must be one of the actions from the factsheet of the AGV.
    pub action_type: String,
    /// Defines if the action is blocking.
    pub blocking_type: BlockingType,
    /// Optional parameters for the action.
    /// The actionParameters must be a valid JSON object, as defined in the factsheet for the action.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_parameters: Option<serde_json::Value>,
}

/// Defines if the action is blocking.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum BlockingType {
    /// The AGV can execute the next action in parallel.
    #[serde(rename = "NONE")]
    None,
    /// The AGV can execute the next action in parallel, but it has to wait for the action to finish before it can start the next one.
    #[serde(rename = "SOFT")]
    Soft,
    /// The AGV has to wait for the action to finish before it can start the next one.
    #[serde(rename = "HARD")]
    Hard,
}

/// The position of a node in a map.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct NodePosition {
    /// X-coordinate described in the world coordinate system. In [m].
    pub x: f64,
    /// Y-coordinate described in the world coordinate system. In [m].
    pub y: f64,
    /// Identifier of the map.
    pub map_id: String,
    /// Orientation of the AGV at the node in [rad].
    #[serde(skip_serializing_if = "Option::is_none")]
    pub theta: Option<f64>,
    /// Allowed deviation in XY plane in [m].
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed_deviation_xy: Option<f64>,
    /// Allowed deviation in orientation in [rad].
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed_deviation_theta: Option<f64>,
}

/// A trajectory for the AGV to follow, based on a NURBS curve.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Trajectory {
    /// Header ID of the trajectory.
    pub header_id: u32,
    /// Degree of the spline.
    pub degree: u8,
    /// Knot vector of the spline.
    pub knot_vector: Vec<f64>,
    /// Control points of the spline.
    pub control_points: Vec<ControlPoint>,
}

/// A control point of a spline.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct ControlPoint {
    /// X-coordinate described in the world coordinate system.
    pub x: f64,
    /// Y-coordinate described in the world coordinate system.
    pub y: f64,
    /// Range: [0.0 ... float64.max]
    /// The weight of the control point on the curve.
    /// When not defined, the default will be 1.0.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub weight: Option<f64>,
}

/// The position of the AGV.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct AgvPosition {
    /// X-coordinate of the AGV in the world coordinate system. In [m].
    pub x: f64,
    /// Y-coordinate of the AGV in the world coordinate system. In [m].
    pub y: f64,
    /// Orientation of the AGV in [rad].
    #[serde(skip_serializing_if = "Option::is_none")]
    pub theta: Option<f64>,
    /// Identifier of the map.
    pub map_id: String,
    /// Indicates if the position is initialized.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub position_initialized: Option<bool>,
    /// Score of the localization. Range: [0.0 ... 1.0].
    #[serde(skip_serializing_if = "Option::is_none")]
    pub localization_score: Option<f64>,
    /// Deviation range of the position. In [m].
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deviation_range: Option<f64>,
}

/// The velocity of the AGV.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Velocity {
    /// Velocity in X direction. In [m/s].
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vx: Option<f64>,
    /// Velocity in Y direction. In [m/s].
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vy: Option<f64>,
    /// Angular velocity. In [rad/s].
    #[serde(skip_serializing_if = "Option::is_none")]
    pub omega: Option<f64>,
}

/// A point in 3D space.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Point {
    /// X coordinate of the point. In [m].
    pub x: f64,
    /// Y coordinate of the point. In [m].
    pub y: f64,
    /// Z coordinate of the point. In [m].
    #[serde(skip_serializing_if = "Option::is_none")]
    pub z: Option<f64>,
}
